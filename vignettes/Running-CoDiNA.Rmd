---
title: "Co-Expression Network Analysis"
author: "Deisy Morselli Gysi, Tiago de Miranda Fragoso, Eivind Almaas and Katja Nowick"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: bib.bib
---
<style>
body {
text-align: justify}
</style>

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The usage of the Co-expression Differential Network analysis has been growing by the Biological and Medical science for the analysis of complex systems or diseases. We have developed a method that is able to compare as many networks as desired, by caracterizing both links and nodes that are common, different or specific to each network. More information can be found at [arXiv:1802.00828].

Here, we illustrate the usage of the CoDiNA method, that can be applied for comparison of multiple networks. 

## Input data

The input data for CoDiNA is a list of data.frame, containing: `Node.1`, `Node.2` and `value`. It is important to mention here that the methodology should be employed only for **undirected graphs**. The `value` is the strength of the link between `Node.1` and `Node.2` and must any real number between -1 to 1. This value can be re-normalized by the package using the argument `stretch = TRUE` (by default the values are normalized).

As an example, the `CoDiNA` package contains 4 datasets from a Cancer study, GSE4290 (@sun2006neuronal). Each one of this datasets was previously normalized, the control quality was done for the genes and the networks were calculate using the `wTO` package (@gysi2017wto; @wTO).
Each dataset consists of the Gene names and the weight only for the significative interactions and filtered for a wTO value of |0.3|.

### Using the wTO output for CoDiNA
The output from the `wTO` package can be easily used as input for `CoDiNA`.


```{r wTO}
require(wTO)
require(CoDiNA)
require(magrittr)

wTO_out = wTO.fast(Data = Microarray_Expression1, n = 100)

wTO_filtered = subset(wTO_out, p.adjust(wTO_out$pval) < 0.05, select = c('Node.1', 'Node.2', 'wTO'))
```

## Creating the Differential Network

To generate the differential network one can use the `MakeDiffNet()` function.

This function will return the $\Phi$ and $\tilde{\Phi}$ classification for each one of the links. Connections that are assigned to $\alpha$ (a) are in agreement in all networks and it means that all networks possess that particular link with the same sign. Links classified as $\beta$ (b) are the ones that also exist in all networks but at least one network contains it with a different sign. The category $\gamma$ (g) contains links that does not exist in all networks, meaning that they are specific to at least one network. 

This function also assigns the link into a sub-category. It is important mainly for the $\beta$ and $\gamma$ links to understand its differences or specificities. It is important to note that **the first network is considered to be the reference for $\beta$ links**.

The output from this function is a data.frame containing the nodes, the original weights (or normalized), the Phi and Phi_tilde categories, a Group, which describes the sign or absence of the link, the Score_center (raw score), Score_Phi (normalized score by $\Phi$), Score_Phi_tilde (normalized score by $\tilde\Phi$), Score_internal (score of the link to its theoretical category). The first 3 scores, should be closer to 1, while for the last one, the closer to 0 the better. 

```{r MakeDiffNet}
DiffNet = MakeDiffNet(Data = list(CTR, OLI, AST), Code = c('CTR', 'OLI', 'AST'))

DiffNet

print(DiffNet) %>% head()
```

## Clustering the nodes into $\Phi$ and $\tilde{\Phi}$ categories
Because exclusively the information about the links is not enough to define a network, it is necessary to define the nodes accordingly to its $\Phi$ and $\tilde{\Phi}$ categories.
To do so, the function `ClusterNodes()` can be used. The input for this function is `DiffNet`, that is the output from the `MakeDiffNet()`, besides the external and internal cutoffs. The external cutoff is applied to the normalized $\tilde\Phi$ Score, while the internal cutoff is applied to the internal Score.

The suggested values for the internal and external cutoffs are the median or the first and third quantiles of the internal and $\tilde\Phi$ scores, depending on how conservative the network should be.

Using the median:

```{r ClusterNodes}
int_C = quantile(DiffNet$Score_internal, 0.5)
ext_C = quantile(DiffNet$Score_Phi, 0.5)

Nodes_Groups = ClusterNodes(DiffNet = DiffNet, cutoff.external = ext_C, cutoff.internal = int_C)
table(Nodes_Groups$Phi_tilde)
```

Using the first and third quantile:

```{r ClusterNodes2}
int_C = quantile(DiffNet$Score_internal, 0.25)
ext_C = quantile(DiffNet$Score_Phi, 0.75)

Nodes_Groups = ClusterNodes(DiffNet = DiffNet, cutoff.external = ext_C, cutoff.internal = int_C)
table(Nodes_Groups$Phi_tilde)
```

## Plotting the network

The visualization of the final network can be quickly done with `plot`. The layout of the network can be also determined from a variety that is implemented in igraph package, the `Make_Cluster` argument allows the nodes to be clusterized according to many clustering algorithms that are implemented in igraph can be used. The final graph can be exported as an `HTML` or as `png`. The argument `path` saves the network in the given path. 

The plot returns the nodes and its information.

```{r plot}
int_C = quantile(DiffNet$Score_internal, 0.25)
ext_C = quantile(DiffNet$Score_Phi, 0.75)

Graph = plot(DiffNet, cutoff.external = ext_C, cutoff.internal = int_C, layout = 'layout_components', path = 'Vis.html')

```

The graph can also be exported as an igraph object, that can be further plotted.

```{r plotigraph}

g = as.igraph(Graph) 

require(igraph)

plot(g, layout = layout.fruchterman.reingold(g), vertex.label = NA)
```


##References
